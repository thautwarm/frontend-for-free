# This file is automatically generated by RBNF.hs
def rbnf_named_lr_step_rbnfmacro_0(rbnf_tmp_0, builtin_state, builtin_tokens):
    #
    #newtmp: lcl_0
    lcl_0 = builtin_match_tk ( builtin_tokens, 6 )
    #release lcl_0
    rbnf_tmp_1 = lcl_0
    #lcl_0
    #reuse: lcl_0
    lcl_0 = rbnf_tmp_1 is None
    #release lcl_0
    #lcl_0
    #reuse: lcl_0
    if lcl_0:
        #
        #newtmp: lcl_1
        lcl_1 = builtin_tokens . offset
        #release lcl_1
        #lcl_1
        #reuse: lcl_1
        lcl_1 = ( lcl_1, "quote a not match"  )
        #release lcl_1
        #lcl_1
        #reuse: lcl_1
        lcl_1 = builtin_cons ( lcl_1, builtin_nil )
        #release lcl_1
        #lcl_1
        #reuse: lcl_1
        lcl_1 = ( False, lcl_1  )
        #release lcl_1
        lcl_0 = lcl_1
    else:
        #lcl_1
        #reuse: lcl_1
        lcl_1 = append ( rbnf_tmp_0, rbnf_tmp_1 )
        #release lcl_1
        rbnf_tmp_1_ = lcl_1
        #lcl_1
        #reuse: lcl_1
        lcl_1 = ( True, rbnf_tmp_1_  )
        #release lcl_1
        lcl_0 = lcl_1
    return lcl_0
def rbnf_named_lr_loop_rbnfmacro_0(rbnf_tmp_0, builtin_state, builtin_tokens):
    rbnf_named_lr_rbnfmacro_0_reduce = rbnf_tmp_0
    #
    #newtmp: lcl_0
    lcl_0 = builtin_tokens . offset
    #release lcl_0
    rbnf_named__off_0 = lcl_0
    #lcl_0
    #reuse: lcl_0
    lcl_0 = rbnf_named_lr_step_rbnfmacro_0 ( rbnf_named_lr_rbnfmacro_0_reduce, builtin_state, builtin_tokens )
    #release lcl_0
    rbnf_named_lr_rbnfmacro_0_try = lcl_0
    #lcl_0
    #reuse: lcl_0
    lcl_0 = rbnf_named_lr_rbnfmacro_0_try [ 0 ]
    #release lcl_0
    #lcl_0
    #reuse: lcl_0
    lcl_0 = builtin_not_eq ( lcl_0, False )
    while lcl_0:
        #
        #newtmp: lcl_1
        lcl_1 = builtin_tokens . offset
        #release lcl_1
        rbnf_named__off_0 = lcl_1
        #lcl_1
        #reuse: lcl_1
        lcl_1 = rbnf_named_lr_rbnfmacro_0_try [ 1 ]
        #release lcl_1
        rbnf_named_lr_rbnfmacro_0_reduce = lcl_1
        #lcl_1
        #reuse: lcl_1
        lcl_1 = rbnf_named_lr_step_rbnfmacro_0 ( rbnf_named_lr_rbnfmacro_0_reduce, builtin_state, builtin_tokens )
        #release lcl_1
        rbnf_named_lr_rbnfmacro_0_try = lcl_1
        # recalculate condition
        #lcl_1
        #reuse: lcl_1
        lcl_1 = rbnf_named_lr_rbnfmacro_0_try [ 0 ]
        #release lcl_1
        #lcl_1
        #reuse: lcl_1
        lcl_1 = builtin_not_eq ( lcl_1, False )
        #release lcl_1
        lcl_0 = lcl_1
    #release lcl_0
    #lcl_0lcl_1
    #reuse: lcl_0
    lcl_0 = builtin_tokens . offset
    #release lcl_0
    #lcl_0lcl_1
    #reuse: lcl_0
    lcl_0 = lcl_0 == rbnf_named__off_0
    #release lcl_0
    #lcl_0lcl_1
    #reuse: lcl_0
    if lcl_0:
        #lcl_1
        #reuse: lcl_1
        lcl_1 = ( True, rbnf_named_lr_rbnfmacro_0_reduce  )
        #release lcl_1
        lcl_0 = lcl_1
    else:
        lcl_0 = rbnf_named_lr_rbnfmacro_0_try
    return lcl_0
def rbnf_named_parse_START(builtin_state, builtin_tokens):
    #
    #newtmp: lcl_0
    lcl_0 = builtin_match_tk ( builtin_tokens, 0 )
    #release lcl_0
    rbnf_tmp_0 = lcl_0
    #lcl_0
    #reuse: lcl_0
    lcl_0 = rbnf_tmp_0 is None
    #release lcl_0
    #lcl_0
    #reuse: lcl_0
    if lcl_0:
        #
        #newtmp: lcl_1
        lcl_1 = builtin_tokens . offset
        #release lcl_1
        #lcl_1
        #reuse: lcl_1
        lcl_1 = ( lcl_1, "BOF not match"  )
        #release lcl_1
        #lcl_1
        #reuse: lcl_1
        lcl_1 = builtin_cons ( lcl_1, builtin_nil )
        #release lcl_1
        #lcl_1
        #reuse: lcl_1
        lcl_1 = ( False, lcl_1  )
        #release lcl_1
        lcl_0 = lcl_1
    else:
        #lcl_1
        #reuse: lcl_1
        lcl_1 = rbnf_named_parse_g ( builtin_state, builtin_tokens )
        #release lcl_1
        rbnf_named__check_1 = lcl_1
        #lcl_1
        #reuse: lcl_1
        lcl_1 = rbnf_named__check_1 [ 0 ]
        #release lcl_1
        #lcl_1
        #reuse: lcl_1
        lcl_1 = lcl_1 == False
        #release lcl_1
        #lcl_1
        #reuse: lcl_1
        if lcl_1:
            lcl_1 = rbnf_named__check_1
        else:
            #
            #newtmp: lcl_2
            lcl_2 = rbnf_named__check_1 [ 1 ]
            #release lcl_2
            rbnf_tmp_1 = lcl_2
            #lcl_2
            #reuse: lcl_2
            lcl_2 = builtin_match_tk ( builtin_tokens, 1 )
            #release lcl_2
            rbnf_tmp_2 = lcl_2
            #lcl_2
            #reuse: lcl_2
            lcl_2 = rbnf_tmp_2 is None
            #release lcl_2
            #lcl_2
            #reuse: lcl_2
            if lcl_2:
                #
                #newtmp: lcl_3
                lcl_3 = builtin_tokens . offset
                #release lcl_3
                #lcl_3
                #reuse: lcl_3
                lcl_3 = ( lcl_3, "EOF not match"  )
                #release lcl_3
                #lcl_3
                #reuse: lcl_3
                lcl_3 = builtin_cons ( lcl_3, builtin_nil )
                #release lcl_3
                #lcl_3
                #reuse: lcl_3
                lcl_3 = ( False, lcl_3  )
                #release lcl_3
                lcl_2 = lcl_3
            else:
                #lcl_3
                #reuse: lcl_3
                lcl_3 = ( rbnf_tmp_0, rbnf_tmp_1, rbnf_tmp_2  )
                #release lcl_3
                #lcl_3
                #reuse: lcl_3
                lcl_3 = builtin_mk_ast ( "START", lcl_3 )
                #release lcl_3
                rbnf_tmp_1_ = lcl_3
                #lcl_3
                #reuse: lcl_3
                lcl_3 = ( True, rbnf_tmp_1_  )
                #release lcl_3
                lcl_2 = lcl_3
            #release lcl_2
            lcl_1 = lcl_2
        #release lcl_1
        lcl_0 = lcl_1
    return lcl_0
def rbnf_named_parse_g(builtin_state, builtin_tokens):
    #
    #newtmp: lcl_0
    lcl_0 = builtin_tokens . offset
    #release lcl_0
    rbnf_named__off_0 = lcl_0
    #lcl_0
    #reuse: lcl_0
    lcl_0 = builtin_peekable ( builtin_tokens, 0 )
    #release lcl_0
    #lcl_0
    #reuse: lcl_0
    if lcl_0:
        # switch
        #
        #newtmp: lcl_1
        #
        #newtmp: lcl_2
        lcl_2 = builtin_peek ( builtin_tokens, 0 )
        #release lcl_2
        #lcl_2
        #reuse: lcl_2
        lcl_2 = lcl_2 . idint
        if lcl_2 == 6:
            #
            #newtmp: lcl_3
            lcl_3 = rbnf_named_parse_rbnfmacro_0 ( builtin_state, builtin_tokens )
            #release lcl_3
            rbnf_named__check_0 = lcl_3
            #lcl_3
            #reuse: lcl_3
            lcl_3 = rbnf_named__check_0 [ 0 ]
            #release lcl_3
            #lcl_3
            #reuse: lcl_3
            lcl_3 = lcl_3 == False
            #release lcl_3
            #lcl_3
            #reuse: lcl_3
            if lcl_3:
                lcl_3 = rbnf_named__check_0
            else:
                #
                #newtmp: lcl_4
                lcl_4 = rbnf_named__check_0 [ 1 ]
                #release lcl_4
                rbnf_tmp_0 = lcl_4
                #lcl_4
                #reuse: lcl_4
                lcl_4 = ( rbnf_tmp_0 , )
                #release lcl_4
                #lcl_4
                #reuse: lcl_4
                lcl_4 = builtin_mk_ast ( "g", lcl_4 )
                #release lcl_4
                rbnf_tmp_1_ = lcl_4
                #lcl_4
                #reuse: lcl_4
                lcl_4 = ( True, rbnf_tmp_1_  )
                #release lcl_4
                lcl_3 = lcl_4
            #release lcl_3
            lcl_1 = lcl_3
        elif lcl_2 == 5:
            #lcl_3lcl_4
            #reuse: lcl_3
            lcl_3 = builtin_mv_forward ( builtin_tokens )
            #release lcl_3
            rbnf_tmp_0 = lcl_3
            #lcl_3lcl_4
            #reuse: lcl_3
            lcl_3 = ( rbnf_tmp_0 , )
            #release lcl_3
            #lcl_3lcl_4
            #reuse: lcl_3
            lcl_3 = builtin_mk_ast ( "g", lcl_3 )
            #release lcl_3
            rbnf_tmp_1_ = lcl_3
            #lcl_3lcl_4
            #reuse: lcl_3
            lcl_3 = ( True, rbnf_tmp_1_  )
            #release lcl_3
            lcl_1 = lcl_3
        else:
            #lcl_3lcl_4
            #reuse: lcl_3
            lcl_3 = ( rbnf_named__off_0, "g lookahead failed"  )
            #release lcl_3
            #lcl_3lcl_4
            #reuse: lcl_3
            lcl_3 = builtin_cons ( lcl_3, builtin_nil )
            #release lcl_3
            #lcl_3lcl_4
            #reuse: lcl_3
            lcl_3 = ( False, lcl_3  )
            #release lcl_3
            lcl_1 = lcl_3
        #release lcl_2
        #release lcl_1
        lcl_0 = lcl_1
    else:
        #lcl_1lcl_2lcl_3lcl_4
        #reuse: lcl_1
        lcl_1 = ( rbnf_named__off_0, "g got EOF"  )
        #release lcl_1
        #lcl_1lcl_2lcl_3lcl_4
        #reuse: lcl_1
        lcl_1 = builtin_cons ( lcl_1, builtin_nil )
        #release lcl_1
        #lcl_1lcl_2lcl_3lcl_4
        #reuse: lcl_1
        lcl_1 = ( False, lcl_1  )
        #release lcl_1
        lcl_0 = lcl_1
    return lcl_0
def rbnf_named_parse_rbnfmacro_0(builtin_state, builtin_tokens):
    #
    #newtmp: lcl_0
    lcl_0 = builtin_match_tk ( builtin_tokens, 6 )
    #release lcl_0
    rbnf_tmp_0 = lcl_0
    #lcl_0
    #reuse: lcl_0
    lcl_0 = rbnf_tmp_0 is None
    #release lcl_0
    #lcl_0
    #reuse: lcl_0
    if lcl_0:
        #
        #newtmp: lcl_1
        lcl_1 = builtin_tokens . offset
        #release lcl_1
        #lcl_1
        #reuse: lcl_1
        lcl_1 = ( lcl_1, "quote a not match"  )
        #release lcl_1
        #lcl_1
        #reuse: lcl_1
        lcl_1 = builtin_cons ( lcl_1, builtin_nil )
        #release lcl_1
        #lcl_1
        #reuse: lcl_1
        lcl_1 = ( False, lcl_1  )
        #release lcl_1
        lcl_0 = lcl_1
    else:
        #lcl_1
        #reuse: lcl_1
        lcl_1 = builtin_empty_list (  )
        #release lcl_1
        #lcl_1
        #reuse: lcl_1
        lcl_1 = builtin_push_list ( lcl_1, rbnf_tmp_0 )
        #release lcl_1
        rbnf_tmp_1_ = lcl_1
        #lcl_1
        #reuse: lcl_1
        lcl_1 = rbnf_named_lr_loop_rbnfmacro_0 ( rbnf_tmp_1_, builtin_state, builtin_tokens )
        #release lcl_1
        lcl_0 = lcl_1
    return lcl_0
